[ 2018-09-13 01:37:24 ] hahha
[ 2018-09-13 01:42:37 ] lalala
[ 2018-09-13 01:43:02 ] arashi is so fucking hs
[ 2018-09-13 01:44:42 ] oops
[ 2018-09-13 03:06:37 ] ---\r\ntitle: \'[TOJ][365]G.大龍貓\'\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：<http://toj.tfcis.org/oj/pro/365/>\r\n\r\n<!--more-->\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query && update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f && a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN << 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( Index <= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l <= nowL && nowR <= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( r <= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid < l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin >> n;\r\n    for ( int i = 1 ; i <= n ; i++ )\r\n        cin >> basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin >> q;\r\n    while ( q-- ){\r\n        cin >> type >> l >> r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout << query ( l, r, 1, n, 1 ).ma.sz << \'\\n\';\r\n    }\r\n}\r\n```
[ 2018-09-13 03:07:10 ] ---\r\ntitle: \'[TOJ][365]G.大龍貓\'\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：<http://toj.tfcis.org/oj/pro/365/>\r\n\r\n<!--more-->\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query && update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f && a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN << 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( Index <= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l <= nowL && nowR <= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( r <= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid < l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin >> n;\r\n    for ( int i = 1 ; i <= n ; i++ )\r\n        cin >> basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin >> q;\r\n    while ( q-- ){\r\n        cin >> type >> l >> r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout << query ( l, r, 1, n, 1 ).ma.sz << \'\\n\';\r\n    }\r\n}\r\n```
[ 2018-09-13 03:08:35 ] ---\r\ntitle: &#39;[TOJ][365]G.大龍貓&#39;\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：&lt;http://toj.tfcis.org/oj/pro/365/&gt;\r\n\r\n&lt;!--more--&gt;\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query &amp;&amp; update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include&lt;bits/stdc++.h&gt;\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f &amp;&amp; a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN &lt;&lt; 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( Index &lt;= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l &lt;= nowL &amp;&amp; nowR &lt;= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( r &lt;= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid &lt; l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin &gt;&gt; n;\r\n    for ( int i = 1 ; i &lt;= n ; i++ )\r\n        cin &gt;&gt; basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin &gt;&gt; q;\r\n    while ( q-- ){\r\n        cin &gt;&gt; type &gt;&gt; l &gt;&gt; r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout &lt;&lt; query ( l, r, 1, n, 1 ).ma.sz &lt;&lt; &#39;\\n&#39;;\r\n    }\r\n}\r\n```
[ 2018-09-13 03:09:48 ] ---\r\ntitle: &#39;[TOJ][365]G.大龍貓&#39;\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：&lt;http://toj.tfcis.org/oj/pro/365/&gt;\r\n\r\n&lt;!--more--&gt;\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query &amp;&amp; update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include&lt;bits/stdc++.h&gt;\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f &amp;&amp; a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN &lt;&lt; 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( Index &lt;= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l &lt;= nowL &amp;&amp; nowR &lt;= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( r &lt;= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid &lt; l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin &gt;&gt; n;\r\n    for ( int i = 1 ; i &lt;= n ; i++ )\r\n        cin &gt;&gt; basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin &gt;&gt; q;\r\n    while ( q-- ){\r\n        cin &gt;&gt; type &gt;&gt; l &gt;&gt; r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout &lt;&lt; query ( l, r, 1, n, 1 ).ma.sz &lt;&lt; &#39;\\n&#39;;\r\n    }\r\n}\r\n```
[ 2018-09-13 03:10:09 ] ---\r\ntitle: &#39;[TOJ][365]G.大龍貓&#39;\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：&lt;http://toj.tfcis.org/oj/pro/365/&gt;\r\n\r\n&lt;!--more--&gt;\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query &amp;&amp; update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include&lt;bits/stdc++.h&gt;\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f &amp;&amp; a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN &lt;&lt; 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( Index &lt;= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l &lt;= nowL &amp;&amp; nowR &lt;= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1;\r\n    if ( r &lt;= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid &lt; l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin &gt;&gt; n;\r\n    for ( int i = 1 ; i &lt;= n ; i++ )\r\n        cin &gt;&gt; basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin &gt;&gt; q;\r\n    while ( q-- ){\r\n        cin &gt;&gt; type &gt;&gt; l &gt;&gt; r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout &lt;&lt; query ( l, r, 1, n, 1 ).ma.sz &lt;&lt; &#39;\\n&#39;;\r\n    }\r\n}\r\n```
[ 2018-09-13 03:12:50 ] ---\r\ntitle: \'[TOJ][365]G.大龍貓\'\r\ndate: 2017-12-26 20:50:14\r\ntags: TOJ\r\n---\r\n### 題目\r\n\r\n給定一個數列，為一群龍貓的『高度』。\r\n定義只要ai + 1 == aj ( i + 1 == j )（這邊的 i, j是指足碼）就稱為愉悅龍貓群\r\n請實作出支援單點修改及區間查詢的code\r\n題目原網址：<http://toj.tfcis.org/oj/pro/365/>\r\n\r\n<!--more-->\r\n\r\n### 解法\r\n\r\n先定義一個資料型態piece，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\r\n \r\n接著定義另外一種資料型態，用在線段樹上維護的node。node包含三個piece，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\r\n \r\n在up兩個node的時候（假設兩個node分別叫 l, r 、up後的node叫stop好了，相對位置 l 在 r 前面），l.fro一定是stop.fro----因為在這兩個區間裡，最前面的愉悅龍貓群一定是 l.fro，同理，stop.bck一定是r.bck。\r\n那麼，stop.ma呢？\r\n\r\nstop.ma有兩種可能性，第一種就是l.ma或r.ma的其中一個（看誰長度大就誰），另外一種就是，如果merge ( l.bck, r.fro )也是一個愉悅龍貓群的時候，可能會比l.ma或r.ma還要大\r\n\r\n\r\n### 總結\r\n\r\n其實這題不難，只是coding有點複雜，query && update都與正常的線段樹差不多，只是up需要思考一下（？）\r\n\r\n\r\n### code\r\n\r\n```cpp\r\n// by. MiohitoKiri5474\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define maxN 100005\r\n\r\nstruct piece{\r\n    int f, s, sz;\r\n};\r\n\r\ninline bool same ( piece a, piece b ){\r\n    return a.f == b.f && a.s == b.s;\r\n}\r\n\r\nstruct node{\r\n    piece fro, bck, ma;\r\n} seg[maxN << 2];\r\n\r\nint basic[maxN];\r\n\r\ninline node up ( node L, node R ){\r\n    node res;\r\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\r\n\r\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\r\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\r\n\r\n        if ( same ( L.fro, L.bck ) )\r\n            res.fro = stop;\r\n        if ( same ( R.fro, R.bck ) )\r\n            res.bck = stop;\r\n\r\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\ninline void build ( int l, int r, int n ){\r\n    if ( l == r )\r\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\r\n    else{\r\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n        build ( l, mid, leftSon );\r\n        build ( mid + 1, r, rightSon );\r\n\r\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n    }\r\n}\r\n\r\nvoid update ( int l, int r, int Index, int n ){\r\n    if ( l == r )\r\n        return;\r\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( Index <= mid )\r\n        update ( l, mid, Index, leftSon );\r\n    else\r\n        update ( mid + 1, r, Index, rightSon );\r\n\r\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\r\n}\r\n\r\nnode query ( int l, int r, int nowL, int nowR, int n ){\r\n    if ( l <= nowL && nowR <= r )\r\n        return seg[n];\r\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\r\n    if ( r <= mid )\r\n        return query ( l, r, nowL, mid, leftSon );\r\n    if ( mid < l )\r\n        return query ( l, r, mid + 1, nowR, rightSon );\r\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\r\n}\r\n\r\nint main(){\r\n    ios::sync_with_stdio ( false );\r\n    cin.tie ( 0 );\r\n    cout.tie ( 0 );\r\n\r\n    int n, q, l, r, type;\r\n    cin >> n;\r\n    for ( int i = 1 ; i <= n ; i++ )\r\n        cin >> basic[i];\r\n    build ( 1, n, 1 );\r\n\r\n    cin >> q;\r\n    while ( q-- ){\r\n        cin >> type >> l >> r;\r\n        if ( type == 1 ){\r\n            basic[l] = r;\r\n            update ( 1, n, l, 1 );\r\n        }\r\n        else\r\n            cout << query ( l, r, 1, n, 1 ).ma.sz << \'\\n\';\r\n    }\r\n}\r\n```
